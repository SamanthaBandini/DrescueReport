\documentclass[a4paper,12pt]{report}
\usepackage{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[pdftex]{graphicx} 
\usepackage{listings}
\newcommand\tab[1][2cm]{\hspace*{#1}}
%\setcounter{secnumdepth}{5}
%\setcounter{tocdepth}{3}
\graphicspath {{figures/}}

\textwidth 6.3 in % Width of text line.
    \textheight 9.2 in
    \oddsidemargin 0 in      %   Left margin on odd-numbered pages.
    \evensidemargin 0 in      %   Left margin on even-numbered pages.
    \topmargin 0.2 in
    \headheight 0 in       %   Width of marginal notes.
    \headsep 0 in
    \topskip 0 in

\title{DRescue - Natural Disaster Alert and Rescue}
\author{Samantha Bandini\\Elisa Casadio\\Martina Giovanelli\\Anna Giulia Leoni\\Sofia Rosetti}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduction}

The project consists in a monitoring and rescue system in case of natural disasters. 

There is a smartphone application which allows users to alert in the event of hearth-\\quake, landslide, fire and other emergencies.
Alerts are collected and processed with the aim of informing the civil protection of the area in order to coordinate rescue teams.
Civil protection desktop applications communicate with each other to get information about available or occupied rescue teams.

User side there is a native Android application used to warn a natural disaster, sending an alert containing the position to the server.

Civil protection side there is a desktop application used to coordinate rescues.

Each civil protection manages a single district, but each rescue team can join different civil protections. This is why coordination is important in order to know real-time which teams are available and, if not, when they will be.


\chapter{Software development process}

\section{Development methodology}

To manage product development we were inspired by Scrum framework, an iterative and incremental agile software development methodology.
According to Scrum method we decided to have face-to-face meetings as often as possible and when not possible due to personal commitments we planned meetings via VoIP.

We have chosen Sofia Rosetti as Product Owner but we proceeded working together and giving always advices and ideas each others.

Despite commitments, we tried to organize face-to-face meetings at least once every two weeks, most frequently in the first and last period. So, working at home, we tried to follow the following meeting mode.

Every morning teams member available to work on that day had a morning meeting (few minutes) via VoIP or, most frequently, via instant chat, to plan the daily job.
Often, in addition to that concise morning meeting, we made a brief evening meeting to aware others members about problems encountered or doubts during work.

We planned Sprint meeting (in addition to the specified daily meetings) as follows.

Before each Sprint, a sprint planning was organized (max one hour) in which all group members were present. At the end of each Sprint, we all met together again to do Sprint reviews and Sprint retrospectives. Except for the first Sprint, these two operations took place on the same day.\\
During the Sprint Review meeting one member at time presented to the others in a few minutes what was done, even with brief examples.

Unfortunately, due to external commitments or personal reasons every member couldn't dedicate only to this single project. For this reasons, we couldn't even split equally the tasks between members for each Sprint or split them with equal amount of hours.

So, Sprints' management has been carried out in a flexible way, 
as we can see in the product backlog that can be found together with the release. 

We tried to mantain a product backlog evolving during time and we chose working hours as valuation.

During Sprint planning we compiled a quite generic list fo Sprint tasks, which was redefined and perfectioned when chosen.

An example of how we managed tasks partition and hours count can be seen in Figures \ref{fig:Trello} and \ref{fig:Calendar}.

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{figures/Trello.png}
\caption{Trello board for Sprint 5}
\label{fig:Trello}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{figures/Calendar.png}
\caption{Google Calendar hours count}
\label{fig:Calendar}
\end{figure}

\section{Development tools}
Following development support tools have been used:

\begin{itemize}
\item \textbf{IntelliJ IDEA} as integrated software environment
\item \textbf{Java} and \textbf{Scala} as programming languages
\item \textbf{JUnit} and \textbf{ScalaTest} as testing tools
\item \textbf{Git} as version control system
\item \textbf{GitHub} as version control repository
\item \textbf{Gradle} as build automation system
\item \textbf{Travis CI} as continuous integration service
\item \textbf{Trello} as web project management application
\item \textbf{TeamViewer} as team collaboration and working tool
\item \textbf{Google Drive} and \textbf{Dropbox} for sharing files and working simultaneously
\item \textbf{Google Calendar} and \textbf{GTimeReport} for working hours count
\end{itemize}

\chapter{Requirements}
%(2-3 facciate)
%Attenzione ai requirement non funzionali: 1) non siano troppo vaghi altrimenti sono inverificabili, e quindi praticamente inutili; 2) il sistema è distribuito, quindi è inevitable dire cosa vi aspettate in termindi di robustezza a cambiamenti/guasti (quali?, come?), e scalabilità

\section{Functional requirements}

According to agile methodologies in the first Sprint we wrote user cases like ``As.. I want.. For..", which have highlighted these functional requirements:

\begin{itemize}
\item \textbf{User side}:
\begin{enumerate}
\item A not logged user has to register or login to access the platform.
\item A user needs to view last fifty alerts of his area, to see what happens nearby.
\item A user needs to send an alert to inform civil protection about a particular event.
\item A user needs to view his profile to check his register information.
\item A user needs to change his password to update it.
\item A user needs to confirm an alert (upvoting it) to increase the alert reliability.
\end{enumerate}
\end{itemize}

\begin{itemize}
\item \textbf{Civil protection side}:
\begin{enumerate}
\item A civil protection has to login to access the platform.
\item A civil protection needs to receive alerts of its area to coordinate the rescues.
\item A civil protection needs to visualize in action rescues to have a general view of rescues and occupied teams.
\item A civil protection needs to enroll a rescue team in to send it when needed.
\item A civil protection needs to receive notifications when a team is occupied in order to know which ones to send.
\item A civil protection needs to decide which team is the most appropriate to send (at discretion of the civil protection user).
\item A civil protection needs to notify the sending of a team for a specific alert in order to intervene in case of emergency.
\item A civil protection needs to notify the end of a rescue to inform other civil protections that the team is available again.
\end{enumerate}
\end{itemize}

\begin{itemize}
\item \textbf{Server side}:
\begin{enumerate}
\item The server has to forward the alerts and the upvotes to the civil protection of the area in order to warn it.
\item The server has to interact with the database as for user and civil protection requests in order to save datas. 
\end{enumerate}
\end{itemize}

\section{Non-functional requirements}
Non-functional requirements have been identified as following:

\begin{itemize}
\item Alerts must have a certain reliability, so that civil protections won't receive untruthful alerts and the database won't be overloaded with too many alerts relative to the same event. This way, users can signal the event easier and faster, query executions are simplified and civil protections can visualize last alerts and alerts with recents upvotes at the top of the list.
\item The mobile application must be user-friendly.
\item Civil protection views must be updated real-time without performing a specific request.
\item Alert information must be saved into a database.
\end{itemize}

\chapter{Architectural design}

The system's components, shown in figure \ref{fig:ArchDesign}, are:

\begin{itemize}
\item a \textbf{mobile application}, which main purpose is sending alerts to report natural disasters;
\item a \textbf{desktop application}, which main purpose is monitoring natural disasters and coordinate rescues;
\item a \textbf{remote server}, that communicates with clients to send responses and forward alerts to right civil protections;
\item a \textbf{remote database}, that stores all system data. Only the server can access to the database and retrieve data depending on the requests;
\item \textbf{RabbitMQ}, a message broker that allows communications among clients and between clients and server.
\end{itemize}

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{figures/BaseArchitecture.png}
\caption{System Architecture}
\label{fig:ArchDesign}
\end{figure}

\section{Patterns}

\subsection{Model-View-Controller}
As civil protection is a desktop application which consists of a relevant visual part, it has been handled using the Model-View-Controller pattern, that allows to decouple major components for efficient code reuse and parallel development.

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{figures/MVC.png}
\caption{MVC}
\label{fig:MVC}
\end{figure}

As shown in Figure \ref{fig:MVC}, MVC has been arranged with a major controller that communicates with four minor controllers, each one relative to a single view.


\subsection{Data Access Object}
Data Access Object (DAO) is a commonly used pattern to persist domain objects into a database. The most common form of a DAO pattern is a class that contains CRUD methods for a particular domain entity type.
The pattern has these advantages:
\begin{itemize}
\item It separates the domain logic that uses it from any particular persistence mechanism or APIs.
\item The interface methods signatures are independent of the content of the implementation class. When you add a field to the Object of DAO, you don’t need to change the interface nor its callers.
\end{itemize}

A better pattern is Repository, it uses a metaphor of a Collection. This metaphor gives the pattern a tight contract and makes it easier to understand.

In addition in this case, inheritance, abstract classes, and template methods are used to avoid duplicate code since all models need some common methods, this will be discussed in the next chapters.
So we have a GenericDAO, with the basic methods, from which all other DAOs extends.
In the following code segment is shown how a GenericDao is composed.

\lstinputlisting[label=lst:listato1]{code/DAO.java}

The \textit{insert} and \textit{delete} methods look identical to the methods of the simple DAO's, but the \textit{selectByIdentifier} method differs to the standard DAO’s \textit{findById} method by taking an ObjectModel object rather than the object identifier. 
Making this change you avoid to expose the type of ObjectModel identity to the interface.

In our case Repository pattern is realized with DAO.

\subsection{RabbitMQ Broker}
It was decided to adopt the Message-Oriented Middleware (MOM) RabbitMQ for the following reasons:
\begin{itemize}
\item \textbf{Decoupling}: messages can be exchanged between system components which have been placed on the same or different network.
\item \textbf{Flexibility}: heterogeneous integration between technology stack and different types of clients is guaranteed by AMQP (Advanced Message Queuing Protocol implemented by RabbitMQ) whose main responsibility is the interoperability of the systems inside the messaging systems.
\item \textbf{Scalability}: system can scale horizontally easily by adding new Consumer.
\end{itemize}

A message producer produces messages and sends them to the Message Broker which
routes messages to the right consumers. A message consumer await the upcoming messages, then processes the information in them.

\subsubsection{Point-to-Point}
Point-to-Point communication has been used for communicating with the server where more clients can potentially send messages to a queue on which a server consumer of a specific service is waiting for messages.

When the server receives a message, it is processed and the result can be 
\begin{itemize}
\item sent as a response 
\begin{figure}[ht]
\centering
\includegraphics{figures/RPC.jpg}
\caption{Response}
\label{fig:RPC}
\end{figure}
\item forwarded to another client
\begin{figure}[ht]
\centering
\includegraphics{figures/forward.jpg}
\caption{Forward}
\label{fig:forward}
\end{figure}
\end{itemize}

\subsubsection{Publish/Subscribe}
Publish/Subscribe communication has been used to send a message to multiple clients with consumer consuming on the same queue. 
Messages are not published directly to a queue, instead, the producer sends messages to an exchange.
An exchange is responsible for the routing of the messages to the different queues. 
The routing key is a message attribute added into the message header by the producer and it can be seen as an ``address'' that the exchange uses to decide how to route the message. 
A message goes to the queue(s) whose binding key exactly matches the routing key of the message.
Subscribers need to bind to the exchange in order to receive messages.
This is used when a civil protection notices all other civil protecions about the availability of a specific rescue team.

\begin{figure}[ht]
\centering
\includegraphics{figures/ps.jpg}
\caption{Publish-Subscribe}
\label{fig:PS}
\end{figure}

\chapter{Detail design}

\section{Graphical User Interface Design}

Before the applications implementation, the graphical user interface design is an important stage. In this section, the applications mockups will be shown.

\subsection{Mobile App}

The graphical user interface for mobile application has been designed in order to answer all functional requirements user side and to be user-friendly.

In Figure \ref{fig:Mobilemockup}, the mockups realized for mobile application are shown. There are two main screens: one for the user not logged and one for the user logged.

The first main screen is designed to allow a user to login with his credentials and a new user to register.

The second main screen allows a logged user to reach the screens to see all the last alarms in the district where the user is, to send a new alarm and to see and manage his profile.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{figures/mockupMobile.png}
\caption{Mobile user application mockups}
\label{fig:Mobilemockup}
\end{figure}

\subsection{Civil Protection}

The graphical user interface for civil protection desktop application has been designed in order to allow civil protection users to receive real-time updates and to perform all actions relative to enroll a new rescue team and start or stop a rescue for a specific alert. This requires the existence of a view where last alerts are shown, and a more specific view in which civil protection users can see which rescue teams are available and which are occupied. A rescue team can be occupied by different civil protections, so the system has been designed to let users know which civil protection started the rescue and when it ends.

Civil protection application mockups are shown in Figure \ref{fig:CPmockup}.

When civil protection application starts, the first shown screen is the login one, where there's the need to insert the specific civil protection username and password.

Once logged, the home screen allows to see the last alerts relative to the civil protection operating area. If a new alert is sent, the view automatically updates showing it at the top of the list, because it's the most recent one. This also happens if a new upvote is sent, so the upvoted alert is moved at the top of the list.

From the home view, clicking on the ``\textit{Enroll team}'' button, there is the possibility to enroll a new rescue team. On the left side of the screen a list containing existing but not enrolled teams is present, while on the right side there is the possibility to register a not already existing rescue team with all relative data. With the ``\textit{Add}'' button, the new rescue team is stored into the database, and the relative left list is updated, allowing the user to select the team in order to enroll it.

Still from the home view, civil protection users can select an alert and by clicking on the ``\textit{Start rescue}'' button can select the appropriate rescue team to send.

To manage rescues in order to stop a rescue if necessary, civil protection users can click on the ``\textit{Manage rescues}'' button, which shows a screen where there's only the possibilty to stop the rescue team.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{figures/CPmockup.png}
\caption{Civil protection mockups}
\label{fig:CPmockup}
\end{figure}

\section{Code organization}
The code is contained within the same project organized in modules:
\begin{itemize}
\item \textbf{civilprotection} contains the civil protection application, which is organized according to the MVC pattern; 
\item \textbf{mobileuser} contains the Android application; 
\item \textbf{server} contains the classes related to server services and database;
\item \textbf{utils} contains the classes related to geocoding and geodecoding operations as well as the messages exchanged between server and civil protections. This module is imported by the civil protection and server one; 
\item \textbf{utils-java} contains only Java code and it is imported by all the other modules. It contains: 
\begin{itemize}
\item the model of the entire project
\item the classes used to manage the connection to RabbitMQ broker
\item some utilities classes
\item the template classes to build messages as well as the class to serialize and deserialize them using Gson library
\item the messages exchanged between mobile application and server
\end{itemize}
\end{itemize}

Some package names are repeated within the various modules and contain classes that have the same usefulness. The most used are
\begin{itemize}
\item package \texttt{connection} which contains the classes that deal with the connection to the RabbitMQ broker
\item package \texttt{communication} which contains the classes that deal with messages exchanged among the system components
\end{itemize}

\section{Server and Database}
It was decided to use a remote server and a remote database, both hosted by Amazon AWS, to have instances always available and accessible from everyone, as the system was designed to be of public utility.

More specifically, the remote server is running on an EC2 instance (t2.micro) where a service always keeps it alive. The remote database is hosted on an RDS instance, accessed only from the server instance. It was decided to use MySQL because of previous knowledge of the relational model.

\section{Patterns}
\begin{itemize}
\item \textbf{Builder}: the builder pattern was used for model classes and those of messages that had more than 2-3 arguments at constructor.
\item \textbf{Template Method}: the template method pattern was used in handling server response in case of RPC and to group similar objects with common methods in accessing database.
\item \textbf{Singleton}: the singleton pattern was used for the Coordinator implementation to keep the process status in relation to the critical section in Ricart-Agrawala algorithm.
\item \textbf{View-Holder}: the view-holder pattern was used into Android adapter to store each of the component views inside the tag field of the Layout in order to access them without the need to look them up repeatedly.
\item \textbf{Adapter}: the adapter pattern was used as a bridge between a view and the underlying data for that view; it provides access to the data items and it is also responsible for making a view for each item in the data set.
\item \textbf{Static factory}: the static factory pattern was used to create database connection.
\item \textbf{Factory pattern}: the factory pattern was used to retrieve the DAOs of database tables.
\item \textbf{Observer}: the observer pattern was used to manage the view update as a result of model changes.

\begin{center}
\begin{tabular}{ |c|c| } 
\hline
Observer 			& Observable \\
\hline
GpsListener 		& GPS \\
Controller of CPs 		& CivilProtectionData\\
\hline
\end{tabular}
\end{center}

\end{itemize}

\section{Communication messages}
As it was decided to use a Message-Oriented Middleware it was necessary to define a template for the many messages exchanged between system components. It is shown in figure \ref{fig:messageStruct}.

\begin{figure}[ht]
\centering
\includegraphics[scale=0.5]{figures/messages.png}
\caption{Base messages structure}
\label{fig:messageStruct}
\end{figure}

The tables below shows the messages that are exchanged using point-to-point communication.

Mobile user - server communication:

\begin{center}
\begin{tabular}{ |p{4cm}|p{4cm}|p{4cm}|p{2cm}| } 
\hline
Service 			& Request message 	& Response message		& Type 	\\
\hline
Sign Up  			& SignUpMessage(name, surname,email,pass word,phoneNumber)		& SuccessfulMessage 	& RPC	\\ 
Login 				& LoginMessage(email, password) 	& ResponseLoginMessage (UserImpl,List$<$Event TypeImpl$>$)	& RPC	\\ 
Request profile 	& RequestProfileMessage (email)		& ProfileMessage(User Impl)	& RPC	\\ 
Change password		& ChangePasswordMess age(email,oldPassword, newPassword)	& SuccessfulMessage	& RPC	\\
Get alerts		& RequestAlertsMessage (latitude,longitude)	& AlertsMessage(List $<$AlertsImpl$>$)	& RPC	\\
New alert		& NewAlertMessage(user ID,eventType,latitude, longitude)	& no response but ForwardObjectMessage (List$<$String$>$,Object Model)	& forward	\\
Upvote alert		& RequestUpvoteAlert Message(userID, alertID)	& no response but ForwardObjectMessage (List$<$String$>$,Object Model)	& forward	\\
\hline
\end{tabular}
\end{center}

Civil protection - server communication:

\begin{center}
\begin{tabular}{ |p{4cm}|p{4cm}|p{4cm}|p{2cm}| } 
\hline
Service 			& Request message 	& Response message		& Type 	\\
\hline
Login	& CpLoginMessage(cpID, password)	& RescueTeamsMessage (List$<$RescueTeamImpl$>$) 	& RPC	\\ 
Get alerts CP	& RequestCpAlertsMes sage(cpID,password)	& AlertsMessage (List$<$AlertImpl$>$) 	& RPC	\\ 
Register team at CP		& EnrollRescueTeamMess age(rescueTeamID,cpID)	& SuccessfulMessage & RPC	\\ 
Get CP of rescue team 	& GetAssociatedCpMess age(rescueTeamID)		& CivilProtectionsMess age(List$<$CivilProtec tionImpl$>$)	& RPC	\\ 
New team	& NewRescueTeamMess age(rescueTeamID,name, password,latitude,lon gitude,phoneNumber)	& SuccessfulMessage	& RPC	\\
Get not enrolled rescue teams & GetRescueTeamsNot EnrolledMessage	& RescueTeamsMessage (List$<$RescueTeamImpl$>$)	& RPC	\\
\hline
\end{tabular}
\end{center}

The sequence diagrams in figure \ref{fig:seqRPC} and \ref{fig:seqForward} show two examples of successful scenarios respectivly for the response case and the forward one.

\begin{figure}[ht]
\centering
\includegraphics[scale=0.5]{figures/seqRPC.png}
\caption{Response Sequence Diagram}
\label{fig:seqRPC}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[scale=0.5]{figures/seqForward.png}
\caption{Forward Sequence Diagram}
\label{fig:seqForward}
\end{figure}

The table below shows the messages that are exchanged using publish/subscribe communication.

Civil protection - Civil protection communication:

\begin{center}
\begin{tabular}{ |p{4cm}|p{4cm}|p{4cm}|p{2cm}| } \hline
Service 			& Request message 	& Response message		& Type 	\\
\hline
Get Rescue Team Condition	& ReqRescueTeam ConditionMessage(RescueTeamID)	& ReplyRescueTeam ConditionMessage(RescueTeamID, RescueTeamCondition) 	& p/s	\\ 
Update Rescue Team Condition	&  ReplyRescueTeam ConditionMessage(RescueTeamID, RescueTeamCondition) 	& 	& p/s	\\ 
Coordination	&  ReqCoordinationMessa ge(RescueTeamID, reqTimestamp) 	& ReplyCoordinationMes
sage(RescueTeamID, rescueTeamCondition)	& p/s	\\
Coordination	&  ReplyCoordinationMessa ge(RescueTeamID, rescueTeamCondition) 	& 	& p/s	\\
\hline
\end{tabular}
\end{center}

\chapter{Implementation}

\section{Samantha Bandini}
In the DRescue project, Samantha Bandini contribution was mainly related to design and implementation of:
\begin{itemize}
\item Data Access Layer 
\item Handle Exception DB-Server in collaboration with Anna Giulia Leoni and Elisa Casadio
\item Handle MVC in civil protection in collaboration with Sofia Rosetti
\end{itemize}

\subsection{Data Access Layer}

Our application must access a database, so it needed some logic to handle database access. In order to keep the code clean and modular, the database access logic is isolated into \texttt{server/src/main/java/it/unibo/drescue/database} package, which contains the following elements.

\subsubsection{DB connection classes}
\texttt{DBConnection.java} and \texttt{DBConnectionImpl.java} are respectively the interface and the class used to model the access method to DB and its tables.

It uses two static factory methods instead of constructor. These methods, \\ \texttt{getRemoteConnection()} and \texttt{getLocalConnection()}, are static methods that return an instance of the class with some specific settings for environment, like address, username and password used to connect to DB. One advantage of this pattern is that in this way it has name, in this case it was useful for specifying the criteria to choose the connection (local or remote).

As specified in previous chapters the DAO pattern was used for Data Access Layer. Since the DBConnectionImpl class is the one that keeps the general information about the database, information about DB tables are also maintained here, like its relative DAO. Here is maintained the enum with all table's name and the method \texttt{GenericDaoAbstract getDAO(final Table table)} which is a factory that returns the Dao relative to that table.

\subsubsection{DAO classes}
\texttt{dao package}: It contains all DAO with their interfaces as specified in design chapter.

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{figures/ClassDiagram.jpg}
\caption{Class Diagram}
\label{fig:ClassDiagram}
\end{figure}

The DAOs are organized as specified in the partial class diagram in Figure \ref{fig:ClassDiagram}. 

Inheritance and template methods are used to group similar DAOs. The three main DAO's are \textit{GenericDao}, \textit{LoggableDao}, \textit{UpdatableDao}. The GenericDao is the main class from which all others DAO extend, it contains the template methods insert, delete, selectByIdentifier, insertAndGet with abstract methods to be implemented in the classes that extend it.
The UpdatableDao contains the template method update, the LoggableDao contains the template method login and the abstract methods are:
\begin{itemize}
\item \texttt{String getQuery(final QueryType queryType)}: given a query type it returns the prepared query (a composed string) for this object
\item \texttt{PreparedStatement fillStatement(final ObjectModel objectModel, \\final PreparedStatement statement, final QueryType queryType)}: given an object and a prepared statement it returns that prepared statement filled with the useful information to execute the specified query
\item \texttt{ObjectModel mapRecordToModel(ResultSet resultSet)}: gets an object from a resultSet given, obtained from a select query by identifier
\end{itemize}

An example of a particular DAO is CpEnrollment: its method \texttt{List<RescueTeam>} \texttt{findAllRescueTeamGivenACp(String cpID, boolean related)}
has the parameter \textit{related} that is the criteria used to choose the query, since for the CpEnrollment we need both methods \texttt{findAllRescueTeamRelatedToACp} and \texttt{findAllRescueTeamNotRelatedToACp}, with both returning a list of RescueTeam objects that differs only for the query.

Every DAO concrete class has been tested trying to isolate single pieces of the code. Following in broad terms the Test-Driven-Development, JUnit simple test classes have been written before each DAO class, and, in order to respect design principle also in test classes, these classes have been refactored. They can be found under the package\\ \texttt{server/src/test/java/it/unibo/drescue/database}.

\subsubsection{DB initialization classes}
\texttt{helper package}: it contains the class DBInitializationStart used to initialize DB with static tables contents and some other data contained in externals file, to have something to start with.
The external files are located in \textit{server/res}. The DBinitialization interface has a method used to insert into DB all objects listed in a json file, with a parameter \textit{table} that indicates the criteria, so in which table it has to be inserted, and the \textit{pathFile} that indicates the path where the file with objects is located.

To initialize the DB in this way, it was created in utils-java module, in package \texttt{src/main/java/it/unibo/drescue/database}, a class \texttt{JsonFileUtils.java} with the generic method \texttt{<T> List<T> getListFromJsonFile(final String path, \\final Class<T[]> type)} that gets a generic list of objects from a json file indicating the path of the file and the type of the class of the object to get.

\subsubsection{Travis configuration for mysql}
Tests that cover the database part must be run locally, so that they do not act on the remote database that is being used by the real application, but on a copy of this in local environment.
To do this, we had to prepare a .sql document to initialize all database tables and each of us, on a machine where SQL Server and SQL Workbench were installed, ran this file locally.
The problem came up when these tests had to be run in Travis. In addition to add the mysql service to the .travis.yml file, it was necessary to configure the credentials for Travis like in our local environment and also to create the DB with all tables.

These rows has been added to .travis.yml file:\\
\texttt{before}\textunderscore\texttt{install:}\\
\texttt{- mysql -u root --password="" < travis.sql}
\\where travis.sql is a file .sql that contains all configuration specified above.

\section{Elisa Casadio}
The developed part mainly concerns the total or partial definition, design and development of the Android application and the server.

\subsection{Android application}
The code mentioned in this section is available in the \texttt{mobileuser} module.
\subsubsection{GPS}
GPS is a very important component within the application, as it is useful to indicate the exact location from which a user alert is sent and also to display all the alerts in the area where the user is located.

So, the application must have permissions to access the GPS, because the GPS is a sensitive data and it needs the explicit consent of the user to be able to use it. Moreover, the device must have the GPS activated, because otherwise it would not be possible to understand where the user is and the latitude and longitude values could not be obtained.

The package \texttt{gps} contains an activity in which the required permissions and presence of the GPS provider are checked during creation and resume of activity. It also provides the latitude and longitude values, but if they aren't available a specific message is set. Using the \emph{observer} pattern, the activity is notified when the latitude and longitude values change or when the provider is disabled.

This activity is extended by all those activities that need to use the GPS, so that they can have the location values or check the provider.

\subsubsection{Layouts and Activities}
Four activities have been implemented with the relevant layouts to allow the user to send a new report, view the profile, change their password and the home page of application.

\begin{itemize}
\item \texttt{NewAlertActivity} in the package \texttt{alert} is the main feature that the application has, because it allows the user to report a natural disaster. The class extends the GPS activity, because it needs to know the latitude and longitude values to show to the user and comunicate them to the server. In the layout, in addition to GPS values, it is given to user the possibility to select the type of natural disaster that occurs, by choosing between those in the database. The list of possible natural disasters is downloaded only whenever the user logs in, so as not to slow down the operation, and it's saved between device shared preferences.
\item \texttt{ProfileActivity} in the package \texttt{profile} shows the user data. The data are downloaded when the user logs in and they are saved in the shared preferences of the device. Each field is set by taking the value saved in the shared preferences that has a certain key. The keys that can be used are listed in the \texttt{PreferencesKey} enum in the package \texttt{utils}. From this activity it is possible to reach the activity for change the profile password and do logout. The logout is very simple, it just deletes all the data saved in the shared preferences.
\item \texttt{ChangePasswordActivity} in the package \texttt{profile} allows the user to change his password. So, it is necessary to take the old and the new password, the user email and update his record on database. The layout shows three fields where the user can write. Each field must comply with two rules: the password must be at least 6 characters long and it must contain only alphanumeric characters.
\item \texttt{MainActivity} shows a RecyclerView where the CardView are arranged in a grid. Each CardView contains a title, an icon and a string with the class name that must start at the click of the CardView. The titles, the icons and the strings are listed in \texttt{arrays.xml} in \texttt{res} folder in the form of array. In order to handle the RecyclerView, there was the need to use the \emph{Observer} pattern, the \emph{Adapter} pattern and the \emph{ViewHolder} pattern. Using the \emph{Observer} pattern, it was possible to notify when the user clicks on a specific CardView and to open the relative activity. The \emph{ViewHolder} pattern has allowed to set the correct fields of each CardView and the \emph{adapter} pattern has been the bridge between activity and the ViewHolder. \texttt{MainActivity}, during its creation or its resume, controls that the shared preferences are not empty. If this is not the case, it means that the user has logged out, so it need to go back to \texttt{SplashActivity} where the user can log in again.
\end{itemize}

\subsubsection{Connection between authentication and profile activities and server}
After performing all the layouts and basic activity operations, the connection between the activities and the server was added using the classes contained in the \texttt{connection} package.

The deployed connection is about authentication and profile activities. In all these cases, the type of communication is RPC, so all requests were made using \texttt{RabbitAsyncTask} class. The responses are \texttt{AbstractResponse}, so they were handled differently depending on what was needed to get. For more detailed explanation about \texttt{RabbitAsyncTask} and \texttt{AbstractResponse} see the dedicated section of developer Anna Giulia Leoni.

First, it was necessary to create a message to be sent to the server in order to forward the request, then check the presence of the Internet connection (both through mobile and Wi-Fi connection). This check was essential because forwarding a request without connection could cause an application crash. Moreover, being necessary to receive a response from the server, a progress dialog has been introduced in order to block the user's activity until the application receives any response from the server.

\begin{itemize}
\item \texttt{SignUpActivity} in package \texttt{authentication} was implemented by Anna Giulia Leoni and refactored by Elisa Casadio. The request message consists of all the data that the user has entered during the registration. The response message consists in a simple successful message, which confirms the database registration.
\item \texttt{LoginActivity} in package \texttt{authentication} has the request message assembled by the credentials of user. The response message consists in a message with the user data and a list of natural disaster. All this data are saved in shared preferences to use them in future in some requests or in the application. It has been preferred to have all essential information at the user login, because in this way we avoided to slow down the user when displaying some views, such as profile or new alert.
\item \texttt{ChangePasswordActivity} in package \texttt{profile} has the request message assembled by the new and old password and the user email, the latter derived from shared preferences. The response message is a successful message, which confirms the password update.
\end{itemize}

\subsubsection{Graphics}
To get a user-friendly application, the graphics were helpful. First, the basic colors that would have featured the application were choosen. Tones on green and yellow were chosen so that application could recall nature. Colors are listed within \texttt{colors.xml} so they can be used by all layouts. To have a minor repetition of the code, xml tags have been redefined within \texttt{styles.xml}, while \texttt{strings.xml} and \texttt{dimens.xml} have all the strings shown in the view and all the dimensions of the components used. Finally, the material icons were selected for use within the application.

\subsection{Server application}
In this section, the service exposed is located in \texttt{server} module in \texttt{connection} package.

\subsubsection{MobileuserService}
\texttt{MobileuserService} is a case class used to implement useful operations to access database when requests are made on \texttt{MOBILEUSER\_QUEUE}. This queue takes all the requests concerning authentication and profile management.

The service decides what to do depending on the type of message. Possible message types accepted are:
\begin{itemize}
\item \texttt{SIGN\_UP\_MESSAGE}: it's the message sent when a user is registered into the mobile application. The user data are extracted from the request message and the user is inserted as a new record in the database. If the insert process is successful, \emph{SuccessfulMessage} is returned, otherwise, if an error occurs, it is captured. The email must be unique, so if it is duplicated, \emph{ErrorMessage} with a particular message is returned. This operations have been implemented by developer Anna Giulia Leoni and refactored by developer Elisa Casadio.
\item \texttt{LOGIN\_MESSAGE}: it's the message sent when a user try to login into the mobile application. The user email and password are extracted from the request message and the user is searched into the user table of database. If the user is found, \emph{ResponseLoginMessage} is sent with all user data and a list of natural disaster, otherwise \emph{ErrorMessage} is sent, because email or password is wrong. If an error occurs, it is captured.
\item \texttt{CHANGE\_PASSWORD\_MESSAGE}: it's the message sent when a user wants to change the password of his account. The user email, old password and new password are extracted from the request message. The user is searched into the user table of database, the old password sent is compared with the real password and the user data are updated.
\item \texttt{REQUEST\_PROFILE\_MESSAGE}: it is useful to get the profile of user. It is implemented for a future functionality. The user email is extracted from message and the user is searched into the user table. If the user is present, \emph{ProfileMessage} is sent with all the user data.
\end{itemize}

This service is tested with \texttt{scalatest} in class \texttt{MobileuserServiceTest} in the \texttt{connec-\\tion} package. For each type of message, the connection with a local instance of database is opened and operations of insert or update are run. Each test checks if the message type is the type expected. At the end, the fake user is deleted and the connection with database is closed.

\section{Martina Giovanelli}
In the DRescue project, Martina Giovanelli contribution was mainly related to design and implementation of communication between civil protections by way of the exchange of JSON messages and the management of rescue teams.
\subsection{Communication between civil protections}
Every civil protection maintain the condition of the rescue teams it has enrolled in in his local memory. 
When the civil protection receives a new alert it must communicate with other civil protections in order to decide which rescue team send to solve the occured natural disaster reported by the users.\\
The rescue teams are shared among the different civil protections so, before select one, they must coordinate with others to recover the picked team status and update their local model.\\
The messages \texttt{ReplyRescueTeamConditionMessage} and\\ \texttt{ReqRescueTeamConditionMessage} inside \texttt{civilprotection} module are exchanged between the different civil protection respectively to request and send the condition of a particular rescue team.\\

We had to guarantee that the concurrent access of processes to a shared data (the rescue teams) is executed in mutually exclusive manner.
To satisfy this requirement we have dediced to use \textbf{ Ricart-Agrawala's algorithm}, a classical mission exclusion algorithm for distributive systems.\\

Communication between processes is based on the following assumptions:
\begin{itemize}
\item Processes communicate by reading and writing variables through the exchange of messages.
\item The delay of sending a message is unpredictable but finished.
\item The channel is reliable. A sent message is received correctly from its recipient. There are no duplications or spurious messages (received but never transmitted). 
\item The process do not fail. 
\end{itemize}

For the implementation of this algorithm two other messages have been used:
\begin{itemize}
\item \texttt{ReqCoordinationMessage}
To request a rescue team, the civil protection sends a timestamped message to all processes.
\item \texttt{ReplyCoordinationMessage}
On receiving a request from any other civil protection, the process sends an OK message if either the process is not interested in entering in CS or if its own request has a higher timestamp value. Otherwise that message is kept in a pending queue.
\end{itemize}
Civil protection is granted the resource when it has requested the resource and it has received the OK message from every other
process in response to its request message.\\

The class \texttt{CoordinatorImpl} and the respective interface \texttt{Coordinator} inside the package \texttt{civilprotection/src/main/java/it/unibo/drescue/utils} represent a singleton used for the implementation of the above algorithm.\\
In particular, this class keeps the process status in relation to the critical section: \texttt{wanted}, \texttt{held} and \texttt{detached}.

The condition of the coordinator is equal to \texttt{wanted} when the civil protection wants to enter into critical section and to update the status of one of its rescue team. 
In this case the coordinator also maintains the timestamp of the request, the list ID of the civil protection from which the process expects n replay message and the critical section's name which corresponds exactly to the name of the rescue team.

The coordinator's condition is equal to \texttt{held} when the process is into critical section and \texttt{detached} when the civil protection isn't interested to occupied one team.
The coordinator keeps the civil protection's condition for only one critical section.\\

\subsection{Rescues management}
Individual contribution in civil protection Model-View-Controller was mainly concerned the management of the rescue team into \texttt{ManageRescuesControllerImpl} class and the handle of the  messages received from other civil protection.

When the civil protection wants to occupy a rescue team it sends a broadcast message to other civil protections that has enrolled in the same rescue team in order to receive their local condition.
It waits until it receives all the reply messages or receives a reply that informs it that the rescue team is already occupied.
In the first case the civil protection can occupy the rescue team, in the other case it must choose another team.

When civil protection wants to stop the rescue team, it updates its local condition from occupied to available and sends a message to other civil protection to inform them about the updated team status.

\section{Anna Giulia Leoni}

The developed part mainly concerns the development of the Server application and the Android one, but also  a little part in the Civil Protection application.

\subsection{Server application}

All the code referred into this section is located into module \texttt{server/scala}.

\subsubsection{Service response, Service forward}
In order to handle the sending of a response and the forward of a message server side, \texttt{ServiceResponse} and \texttt{ServiceForward} traits were created in package \texttt{connection}. These traits extend \texttt{ServiceOperation} overriding and implementing in different ways \textit{handleDBresult}. 

Services that can handle both response and forward extends \texttt{ServiceResponseOr\\Forward} trait which extends both \texttt{ServiceResponse} and \texttt{ServiceForward}. This was possibile because Scala allows implementing functions in traits and multiple inheritance on traits. Basing on the content of the \textit{properties} parameter that came together with the message through RabbitMQ, it is discriminated if the message has to be forwarded or needs a reply and the appropriate \textit{super} method is called.
\\More specifically if the \textit{properties.getReplyTo} content is a valid string then represents the name of the queue to which send the response message returned from \textit{accessDB} method. Otherwise the result of the \textit{accessDB} method is a \texttt{FrowardObjectMessage} containing the ObjectModel to forward and the queues name to which forward it.
\\This behaviour is tested using ScalaTest inside \texttt{TestClientServerCommunication} class in \texttt{test} folder of package \texttt{connection}.
\\

\subsubsection{AlertsService}
Case class \texttt{AlertsService} in package \texttt{connection} extends \texttt{ServiceResponseOrForward} and manages messages requests related to alerts both from mobileuser and civil protection. More specifically these messages are shown in the detail design section.

In handling new alerts and upvotes messages is also necessary to retrieve the civil protections related to the zone from which the alert was sent to forward the alert or the upvote to the rights civil protections. Furthermore in handling new alerts and requests of alerts from mobile, methods of the Geocoding class were used to calculate the district to which register the new alert or to which get the alerts.

\subsection{Android application}

All the code referred into this section is located into module \texttt{mobileuser}.

\subsubsection{Layouts and Activities}
\texttt{ToolbarActivity} is extended by all the activities of the app. As the docs says the native ActionBar behaves differently depending on the Android version the device is using, we used Toolbar instead of ActionBar which has a more uniform behaviour.

Activities have been implemented with the related layouts to allow the user to sign up, login, get and upvote alerts.
\begin{itemize}
\item \texttt{SplashActivity} represents the splash screen of the app where the user can select to sign up or login
\item \texttt{SignUpActivity} and \texttt{LoginActivity} in package \texttt{authentication} represent respectivly the activity that contains the fields that the user must fill to sign up and login. Some checks are made on the validity of the email address and the match between password and confirm password at sign up.
\item \texttt{UpvoteAlertActivity} in package \texttt{alert} represents the activity that contains a list of existing alerts that the user can upvote to increase their reliability. It extends \texttt{GpsActivityImpl} because latitude and longitude of the user are needed to correctly download alerts of its district. \\
The alert list is presented within the app using Adapter and ListView. The \texttt{Alert Adapter} allows access to data and creates the corresponding view based on the layout provided for each alert of the given list. Inside the Adapter the ViewHolder pattern has been used to limit the number of calls to \textit{findViewbyId} method. This ways, this methods is invoked once for each item of the list passed at constructor and references to layout elements are stored in an \texttt{AlertViewHolder} instance associated with convertView with \textit{View.setTag} to be used for next items.
\end{itemize}

\subsubsection{Connection to server}
The package \texttt{connection} contains the classes used to communicate to the server and eventually parse the response.
\\To achieve this goal, Android AsynkTask were used. AsynkTask allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. Within the \textit{doInBackground} method is contained the code to open the connection to the server, send the message and eventually waiting for a response.

More specifically two AsynkTask were created:
\begin{itemize}
 \item \texttt{RabbitAsyncTask} to perform RPC, returning a String result that represents the server response in json format. If the communication timeout is reached or in case of exception during the communication the result consists of an error. The received result is passed to an handler, represented by a class implementing the \texttt{RequestDelegate} interface, in our case \texttt{AbstractResponse} class, which deserializes it basing on message type and addresses it to the abstract methods \textit{onSuccessfulRequest} or \textit{onErrorRequest} implemented for each request to perform specific operations basing on it.
 \item \texttt{RabbitPublishAsyncTask} to send messages using the publish/subscribe paradigm, returning a boolean result that represents the sending outcome. The result is passed to an handler, represented by a class implementing the \texttt{PublisherDelegate} interface, which performs different operations basing on it.
\end{itemize}
The connection to the server was added into the activities of package \texttt{alert} using the above classes. Before sending the message to the server it is always checked that the device is connected to the netword and, if needed, if latitude and longitude values are correct. More specifically
\begin{itemize}
 \item in \texttt{NewAlertActivity} a \texttt{NewAlertMessage} containing the alert data is created, sent and the result of the sending is shown to the user.
 \item in \texttt{UpvoteAlertActivity} a \texttt{RequestUpvoteAlertMessage} containing the upvote data is created, sent and the result is shows as above; a \texttt{RequestAlertsMessage} containing user position is sent through RPC and on receiving the alert list of his district the adapter must be notified. If timeout is reached or an error occurr an error message is shown. 
\end{itemize}

\subsection{Civil Protection application}

All the code referred into this section is located into module \texttt{civilprotection}.

The developed part is strictly connected to request and response messages exchanged between civil protections in order to obtain information about the condition of their rescue teams.
\\These messages are \texttt{ReqRescueTeamConditionMessage} and \texttt{ReplyRescueTeamCondition\\Message}; their reception is handled inside \texttt{RescueTeamConsumer}. More specifically on receiving the first message the civil protection reply with the second one, setting as condition the one stored in \textit{EnrolledTeamInfo} local model for the specific rescue team; on receiving the second one the civil protection update its local model with the condition received.
A message to request enrolled rescue teams conditions is also sent at login and on enrolling a new team.

\section{Sofia Rosetti}
In the DRescue project, Sofia Rosetti contribution was mainly related to design and implementation of:

\begin{itemize}
\item Geocoding and reverse geocoding management
\item Model interfaces and classes
\item Civil protection views
\item Civil protection Model-View-Controller
\item Handle model in civil protection module and handle communication from civil protection to server in collaboration with Samantha Bandini
\end{itemize}

\subsection{Geocoding and reverse geocoding management}
The geocoding and reverse geocoding service needed inside the project were designed and implemented using the Google Maps Geocoding API.

As Google explains, geocoding is the process of converting addresses (like a street address) into geographic coordinates (like latitude and longitude), while reverse geocoding is the process of converting geographic coordinates into a human-readable address.

As for the requirements of the project, it has been necessary to retrieve latitude and longitude coordinates giving a String corresponding to a generic address. This has been possible thanks to a \textbf{geocoding} request. The relative response consists in a JSON containing two root elements, ``status'' and ``results''. The ``results'' element contains an array of geocoded address and geometry information. From the geometry information it has been possible to retrieve the location, which returns latitude and longitude coordinates. 

Instead, \textbf{reverse geocoding} requests have been used to retrieve a district acronym (e.g. FC, RA, RN...) from latitude and longitude coordinates. The relative response contains a ``result'' element here too: instead of the geometry information, in this case we needed the ``address\_components'' information. 

It is composed of different elements like ``country'', ``root'' or ``street\_number'', but the interested one was ``\texttt{administrative\_area\_level\_2}'', which has a short name corresponding exactly to the district acronym we needed.

The \texttt{utils/src/main/java/it/unibo/drescue/geocoding} package contains geocoding interface, relative implementation class and exception class. Geocoding interface provides only two methods \emph{getDistrict()} and \emph{getLatLng()} that meet exactly the two requirements described above.

The \texttt{utils/src/test/java/it/unibo/drescue/geocoding} package contains a JUnit class test which verifies a proper operation.

\subsection{Model interfaces and classes}
In package \texttt{utils-java/src/main/java/it/unibo/drescue/model} there are all model interfaces and classes.

Every model entity represents one database table with all its attributes, so every interface provides methods to access and set the corresponding fields.

In the same package some other classes ending by ``Builder'' can be found. This because for class constructors with more than three fields the Builder pattern has been used.

Each model class has been tested trying to isolate single pieces of the code. For this purpose JUnit test classes have been written together with each model class. They can be found under the \texttt{utils-java/src/test/java/it/unibo/drescue/model} package.

\subsection{Civil protection views}
In order to mantain most of civil protection module implemented using the Scala language, views have been created by hand with \textbf{ScalaFX}. 

Views have been organized as following.

There is a \texttt{MainView} scala class, which represents the ``container'' class and has container elements, like \textit{stage} and \textit{scene}.
Then, four scala classes (\texttt{LoginGrid}, \texttt{HomeGrid}, \texttt{EnrollTeamGrid} and \texttt{ManageRescuesGrid}) represent the \textit{GridPane} which changes depending on the view to be displayed.
Every \textit{GridPane} is built with a row-column structure that allows to position elements and let them cover more than one row or one column.

The \texttt{MainView} provides a method to change the view that creates a new specific grid corresponding to one of the previous classes.

A \texttt{ViewConstants} object has been implemented too with the purpose of collecting all used constants and remove all magic numbers inside view classes.

\subsection{Civil protection Model-View-Controller}
Individual contribution in civil protection was firstly focused on the base application arrangement. The system has been designed following the Model-View-Controller pattern, therefore the views have to handle presentation and user interaction, the model handles the application logic and the controller coordinates model and views.

The civil protection controller is composed of five controller classes, one for each grid and a main controller. This because each grid only communicates with its relative controller, and then each controller can communicate with the main controller.

The grids' container class (\texttt{MainView}) has the reference of each controller in order to instanciate each grid with the proper controller. This has been implemented using the Builder pattern with named parameters.

Some buttons have been inserted to move among views. Every button has been provided of a mouse event able to catch the mouse click. So relative controller methods are called and all relative actions are performed in order to switch to the right view.

Part of the individual contribution was then oriented to implement two scala classes that belong to the civil protection local model.
The \texttt{AlertEntry} and \texttt{EnrolledTeamInfo} classes have been created to simplify insertion and values retrieval from the \textit{TableView} elements contained in the relative views. An \texttt{AlertEntry} element represents a table entry of the \texttt{HomeGrid}, because it's necessary to show the alert ID, the timestamp, latitude and longitude, the user and the district ID, the event name and the upvotes with a table representation. Similarly, the an \texttt{EnrollTeamInfo} element represents a table entry of the \texttt{ManageRescuesGrid}, because in this case it's necessary to show the team ID, name and phone number, if the team is available or not, the ID of the civil protection which occupied the team and the ID of the alert for which the team has been sent.

These two classes are also used in the \texttt{CivilProtectionData} class, which represents the model that every civil protection needs to mantain locally in order to get last alerts list and to manage rescue teams.

\section{Common parts}
Depending on the needs encountered during the implementation, messages were created by each of us with relative tests.

\subsection{Samantha Bandini - Sofia Rosetti}
All work has been carried out according to the pair programming technique.

\subsubsection{MVC package organization}

Civil protection application has been realized in order to focus on the management of data relative to the specific civil protection that is using the system.\\

Code has been organized as \texttt{civilprotection/src/main/scala/it/unibo/drescue/} package shows: 

\begin{itemize}
\item \texttt{controller} package: contains all controller classes.
\item \texttt{view} package: contains all views classes.
\item \texttt{localModel} package: contains classes relative to the logged civil protection local model. Generic model classes (which must be used from other modules too) can be found under \texttt{utils-java/src/main/java/it/unibo/drescue/model} package.
\end{itemize} 

Package localModel contains CivilProtectionData class, which represents the main local model to handle in each civil protection.


\subsubsection{Handle model in civil protection module using pattern Observer}

The views' real-time update has been set up with Observer pattern. Each model change produces a notification and the view is updated through an ObservableBuffer.

Observer pattern has been organized as following: the Observer trait is included in \texttt{civilprotection/src/main/scala/it/unibo/drescue/controller} package, as three minor controllers must implement it. This trait contains a \textit{onReceivingNotification()} method each observer class must implement in order to react to a notification.

In the same way, \texttt{civilprotection/src/main/scala/it/unibo/drescue/localModel} package contains the Observable trait, which is implemented by the CivilProtectionData class in order to notify a change. This trait has an object \textit{Observers} that represent an enumeration with which the right observer is notified. The \texttt{addObserver()} method is used to associate an observer to an observable object, while the \textit{notifyObserver()} method is used to notify the right observer through the enumeration.

\subsubsection{Handle communication from civil protection to server}

Client-server communication for the civil protection side has been mainly handled with classes:

\begin{itemize}
\item \texttt{RequestHandler.scala}, which starts a future that returns a result. The future result is the response which has to be understood from the controller as it is a message encoded with the JSON format.
\item \texttt{AlertConsumer}, which is a RabbitMQ consumer that is waiting for the reception of messages like ForwardAlertMessage and ForwardUpvotedAlertMessage; when received, this consumer arranges for the model update.
\end{itemize}

\subsection{Samantha Bandini - Elisa Casadio - Anna Giulia Leoni}
\subsubsection{Handle DB layer exeptions}
It was decided to handle database exception because to different exceptions corresponds different actions server side. All the database exceptions can be found in package \texttt{database/\\exceptions} of module \texttt{server/java}. More specifically
\begin{itemize}
\item a \texttt{DBConnectionException} is thrown if an error occurr while establishing or closing connection to database, or when asking to access a non-existing table.
\item a \texttt{DBQueryException} is thrown if an error occurr while executing a query.
\item a \texttt{DBDuplicatedRecordException} is thrown while inserting an object into database, when an equal object (with the same identifier) was found in database.
\item a \texttt{DBNotFoundRecordException} is thrown while searching an object into db, when an equal object (with the same identifier) was not found in database.
\end{itemize}
Sometimes when the last two occur, the error is notified to the client, otherwise it is only logged.

\subsection{Elisa Casadio - Anna Giulia Leoni}
\subsubsection{Server structure}
The code executed on server is located inside the \texttt{connection} package in \texttt{server} module.

\begin{itemize}
\item \texttt{ServerMain} represents the main class of the module, contains the code to setup the connection to RabbitMQ broker and runs all the services.
\item \texttt{Service} is a case class that represents a generic service. A new channel is created on the given connection and a new \texttt{ServerConsumer} is added to the channel to consume on the given queue.
\item \texttt{ServerConsumer} is a simple server-side consumer extending the default RabbitMQ consumer and overriding the \emph{handleDelivery} method called when consuming a message. Furthermore, a class implementing \texttt{ServerOperation} trait must be passed to the consumer in order to access database and handle potentially the returning result. In case of \emph{accessDB} method throw an exception, the error is logged, otherwise the result is handled. 
\item \texttt{ServiceOperation} is a trait modelling a general service to access database and handle the result. This trait is implemented by all classes that represent the specific services. The \emph{accessDB} method is where concreate access to database is using the Data Access Object.
\end{itemize}

\subsubsection{Server configuration}
Anna Giulia following AWS Guidelines setup a preconfigured instance with RabbitMQ called \emph{Bitnami}.

Elisa, however, configured the instance Linux machine. First, the Java 8 JDK and Scala 2.12.2 are installed to can run the application. A service is created so that the server application can always be active on the machine. The \texttt{drescue-server.sh} bash file, containing the script to create, start and stop the service on the machine, is added to \texttt{/etc/init.d/} folder. Inside the script, there is the command to execute the application jar.

\subsection{Martina Giovanelli - Anna Giulia Leoni}

\subsubsection{Setup the connection}
The package \texttt{connection} inside \texttt{utils-java} module contains the classes used to setup the communication through rabbitMQ used in every other module that needs to communicate with the server or other clients.
\\\texttt{RabbitMQConnectionImpl} class implements \texttt{RabbitMQConnection} interface and contains methods to setup, close and get the real TCP connection with the RabbitMQ broker by setting the host address, port, username and password. 
\\\texttt{RabbitMQImpl} class implements \texttt{RabbitMQ} interface and contains methods to setup, get and performs other operations related to the virtual connection (\textit{channel}) created on the TCP one like sending a message or adding a new consumer on the channel consuming on a specific queue.

\subsubsection{Message structure definition}
The package \texttt{communication/messages} inside \texttt{utils-java} module contains the template classes representing the messages exchanged within the entire system.
More specifically two type of messages have been created:
\begin{itemize}
\item \texttt{AbstractMessage} implementing \texttt{Message} interface which represents the message to be exchanged in client-server and server-client communication. 
\item \texttt{AbstractRoutingMessage} implementing \texttt{RoutingMessage} interface which represents the message to be exchanged in peer-to-peer communication to address the message to the right civil protections. 
\end{itemize}
This hierarchy is shown in the Detail Design section.

All the system components communicate through messages exchanged in JSON format. The chosen library for this aim is \textit{Gson}. \\
\texttt{GsonUtils} class is a simple wrapper of Gson that contains the method \textit{toGson} to serialize a generic Message into its equivalent JSON representation and the method \textit{fromGson} to deserialize the JSON String passed into a Message of the specified class.

\chapter{Retrospective}

%(descrizione finale dettagliata dell'andamento dello sviluppo, del backlog, delle iterazioni; commenti finali)\\
%Cercate di dare una idea di quanto pensate che i vostri test automatizzati coprano il codice e dove: è importante per stimare il potenziale impatto di una modifica al software\\
%Si noti che la retrospettiva è l'unica sezione che può citare aneddoti di cosa è successo in itinere, mentre le altre sezioni fotografano il risultato finale. Se gli studenti decideranno (come auspicato) di utilizzare un product backlog e/o dei backlog delle varie iterazioni/sprint, è opportuno che questi siano file testuali tenuti in versione in una cartella "process", così che sia ri-verificabile a posteriori la storia del progetto.

According to Agile metodology, we defined each Sprint at the end of the previous one and tasks have been divided among group members in base of preferences and previous knowledge.

Due to Martina Giovanelli's full-time work, she preferred to develop independently a part that didn't slow down general development process. Anyway, she took part of every Sprint closure together with other members.

During the first meetings we met face to face in order to discuss requirements and base architecture of the project, including some architectural pattern to adopt.
We set up all development environments, including the repository and the automatic build tools.

According to the requirements, we decided fundamental system parts to start with and other parts' priority.

We initially wanted to use a Platform-As-A-Service system regardless of the underlying infrastructure, in order to take advantage of the existing APIs. Because of this, we spent some time trying to learn the best way to use the Google App Engine platform.
Unfortunately, we encountered some problems. 
%TODO
%Queste 2 righe sotto le metterei nella Sprint 1 retrospective e sopra scriverei "abbiamo incontrato qualche problema, come si può vedere nel file 'Sprint retrospectives' in the paragraph related to Sprint 1".

%In Italy there is only the possibility to register a commercial account and not a private account. Moreover, the Flexible Environment we needed had only a Beta version of Java 8 and no Scala support.

For these reasons, we decided to switch on Amazon Web Services, which is an Infra-\\structure-As-A-Service. We set up two AWS instances, one for computation (\textit{Amazon Elastic Compute Cloud}) and one for the database (\textit{Amazon Relational Database Service}).

Initially, to test if the remote communication with AWS was working, we implemented the communication using sockets. We also tried to use Akka for communication between civil protections, but in the end we decided to use RabbitMQ in order to have the same communication type for both mobile and civil protection sides. This because RabbitMQ doesn't require to know each receiving address, but only the broker one and the queue to send requests on.

During development, most significant problems were related to:

\begin{itemize}
\item conflicts between Scala and Android, that brought to the creation of a separate module \texttt{utils-java}, containing only Java code;
\item \textit{AndroidILogger} IntelliJ bug, which disables all coding support and allows to find errors only during the build process. For this reason, we had to write only few lines of code before building the working module.
\end{itemize}

We also encountered difficulties in estimating each feature time. This brought to develop last project part (mainly related to the civil protection module) without technical excellence.

Finally, we discovered there is a problem with the RDS instance: sometimes responses are corrupted in spite of correct requests. This brings to the inability of accessing to the database data.
Development tests have been made with local server and local database, and nothing went wrong.

\section{Final judgement}

Although anyone had previously worked in a five people group, relationship and communication were good and each member was helpful with each other.

We are satisfied enough with the project result. In spite of some problems with the RDS instance, we reached a good result where communication brings to real-time updates of data and their relative transmission. It was important to reach this goal, because a possible future expansion may bring to a public benefit.

\section{Future developments}

Database and server have been already designed for possible future expansions, like :
\begin{itemize}
\item civil protections operating on common districts;
\item a session and an authentication token;
\item register real occurred events to keep events history;
\item a smart algorithm that knows which is the best rescue team to send for a rescue;
\item a smart algorithm that suggests when a rescue should be started basing on alerts, upvotes and districts population.
\end{itemize}

Other possible expansions are:

\begin{itemize}
\item showing a map with marks on alerts' location;
\item creation of a rescue team application to accept and notify the rescue end;
\item let the mobile user change his profile data;
\item encrypt passwords to improve system security.
\end{itemize}

\end{document} 
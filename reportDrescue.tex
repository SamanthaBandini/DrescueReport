\documentclass[a4paper,12pt]{report}
\usepackage{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\textwidth 6.3 in % Width of text line.
    \textheight 9.2 in
    \oddsidemargin 0 in      %   Left margin on odd-numbered pages.
    \evensidemargin 0 in      %   Left margin on even-numbered pages.
    \topmargin 0.2 in
    \headheight 0 in       %   Width of marginal notes.
    \headsep 0 in
    \topskip 0 in

\title{DRescue - Natural Disaster Alert and Rescue}
\author{Samantha Bandini\\Elisa Casadio\\Martina Giovanelli\\Anna Giulia Leoni\\Sofia Rosetti}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduction}

%TODO 
{PRIMA: descrizione anche sommaria di cosa il sistema implementato realizza}

%TODO
PROGETTO: Segnalazione, raccolta ed elaborazione dati sulle catastrofi naturali.\\

Il progetto consisterà in un sistema di monitoraggio/intervento in caso di catastrofi naturali. Sarà presente un’applicazione per smartphone che consentirà ai singoli utenti di effettuare una segnalazione relativamente ad una particolare evento (terremoto, frana, incendio…). Le segnalazioni verranno raccolte ed elaborate con lo scopo di fornire indicazioni alla protezione civile per coordinare le squadre di soccorso.
Parte della computazione relativa alla scelta della squadra di soccorso più adeguata sarà distribuita tra i diversi applicativi della protezione civile, che dovranno comunicare tra loro per ottenere informazioni sulle squadre di soccorso disponibili o occupate.


STRUTTURA SISTEMA:\\
lato utente: web app o app Android nativa (più orientato sulla seconda) da cui l’utente segnala l’avvenimento di un terremoto, eruzione vulcanica, tempesta, ecc. inviando al server nella segnalazione la sua posizione; (in questo modo senza la necessità di simulare sensori)
lato coordinatore delle squadre di soccorso: software desktop per coordinare l’arrivo dei soccorsi, decidere quale squadra tra quelle localizzate sul territorio deve intervenire
database per mantenere le segnalazioni
server per fare analisi, segnalare ai coordinatori delle squadre di soccorso che è avvenuta una catastrofe\\

Territorio Italiano\\

LATO OPERATORE: \\
Esempio di come abbiamo pensato la gestione delle squadre di soccorso: 
Un operatore gestisce una zona, sa che può contattare certe squadre di soccorso perchè si sono rese disponibili/rendono servizio presso di lui. Una squadra di soccorso può fornire i propri servizi a più operatori e sono definite in termini di mezzi che hanno a disposizione (es. due volanti, tre camion dei pompieri, due ambulanze…). 
{NOTA: in pratica, come si vede nel disegno fatto nella pagina dopo, non abbiamo un nuovo applicativo per le squadre di soccorso, sono sempre gli operatori ad occuparsene, mantenendo però le informazioni relative alle squadre di soccorso (probabilmente condivise tra alcuni operatori) al loro interno. Abbiamo visto che nella realtà le squadre di soccorso si “iscrivono” presso diverse “protezioni civili”(i nostri operatori)}\\

Esempio d’uso applicativo.
Viene segnalato un incendio da molte persone 
Segnalazioni ritenute veritiere dall’operatore (algoritmo)
L’operatore seleziona la squadra (a sua disposizione) migliore da inviare sul posto 
Una volta interpellata la squadra bisogna fare in modo che tutti coloro che possono attingere a quella squadra vengano a conoscenza del fatto che quella squadra è impegnata momentaneamente, e anche quando questa completa il proprio lavoro. Quindi è necessario mantenere memorizzati le disponibilità delle varie squadre.\\


\chapter{Software development process}

(modalità di divisione in itinere dei task, meeting/interazioni pianificate, modalità di revisione in itinere dei task, scelta degli strumenti di test/build/continuous integration)\\
•	uno studente (ad esempio, chi ha l'idea del progetto) fungerà da product owner, oltre che da sviluppatore\\
•	in un meeting iniziale si rediga un product backlog, e si definisca un primo sprint organizzativo (preparazione della build, identificazione requisiti base e architettura)\\
•	si definiscano via-via delle sprint da 25-30 ore di lavoro (una settimana full-time), in modo da realizzarne 3-4 in tutto\\
•	si cerchi ad ogni sprint di ottenere risultati "tangibili", con già un valore per gli stakeholder (i docenti)\\
•	si tenga anche uno sprint backlog, e si facciano meeting frequenti, e meeting a inizio/fine sprint (con brevissimo report del risultato, anch'esso da tenere in versione)\\

*) Le scelte tecnologiche non dovrebbero essere anticipate troppo per ovvi motivi.. prima le fate prima impattano tutta la parte successiva e quindi diventano più difficilmente riconsiderabili (comunque in linea di principio ogni scelta potrebbero stare ovunque, dai requirement fino all'implementazione) \\

\section{Development methodology}
\section{Development tools}

\chapter{Requirements}
(2-3 facciate)
Attenzione ai requirement non funzionali: 1) non siano troppo vaghi altrimenti sono inverificabili, e quindi praticamente inutili; 2) il sistema è distribuito, quindi è inevitable dire cosa vi aspettate in termindi di robustezza a cambiamenti/guasti (quali?, come?), e scalabilità

\section{Functional requirements}

In according to agile methodologies in the first sprint we write functional requirements with user cases like "As..I want..For.."
- Insert here use cases -\\ 

\section{Non-functional requirements}
- Gli alert devono avere una certa "affidabilità", così da non "disturbare" la protezione civile con alert non veritieri o riempire il db con molte segnalazioni relative allo stesso evento (per questo utilizzati upvotes all'interno di alert)\\
- App mobile user-friendly\\
- Reattività app protezione civile\\
- Sicurezza lato protezione civile per login (si è pensato con token/autenticazione) [tra le cose non fatte]
- Mantenere le informazioni relative agli alert memorizzate su un DB

\chapter{Architectural design}

(pattern architetturali usati, componenti del sistema distribuito, scelte tecnologiche cruciali ai fini architetturali -- corredato da pochi ma efficaci diagrammi)\\

*) Ricordate che una scelta architetturale può ritenersi giustificata o meno (e dovremo capirlo) solo a fronte dei requirement che avete indicato\\

*) L'architettura deve spiegare quali sono i sotto-componenti del sistema (da 3 a 10, diciamo), ognuno cosa fa, chi parla con chi e per dirsi cosa -- i diagrammi aiutano\\

\section{MVC Architecture}
\section{Client-Server Architecture}
\section{RabbitMQ MOM}

\chapter{Detail design}
%TODO
(pattern di progettazione, organizzazione del codice -- corredato da pochi ma efficaci diagrammi)\\
*) Il design di dettaglio "esplode" (dettaglia) l'architettura, ma viene concettualmente prima dell'implementazione, quindi non metteteci diagrammi ultra-dettagliati estratti dal codice, quelli vanno nella parte di implementazione

\chapter{Implementation}

*) L'implementazione "esplode" il design, ma solo laddove pensiate che serva dire qualcosa

\section{Samantha Bandini}
\section{Elisa Casadio}
\section{Martina Giovanelli}
\section{Anna Giulia Leoni}
\section{Sofia Rosetti}
%TODO Common part

%TODO chapter or section?
%\chapter{Testing}

\chapter{Retrospective}

(descrizione finale dettagliata dell'andamento dello sviluppo, del backlog, delle iterazioni; commenti finali)\\

*) Cercate di dare una idea di quanto pensate che i vostri test automatizzati coprano il codice e dove: è importante per stimare il potenziale impatto di una modifica al software\\


Si noti che la retrospettiva è l'unica sezione che può citare aneddoti di cosa è successo in itinere, mentre le altre sezioni fotografano il risultato finale. Se gli studenti decideranno (come auspicato) di utilizzare un product backlog e/o dei backlog delle varie iterazioni/sprint, è opportuno che questi siano file testuali tenuti in versione in una cartella "process", così che sia ri-verificabile a posteriori la storia del progetto.

\section{Final judgement}
\section{Future developments}

\end{document}


















\newpage

Some useful latex commands:\\

\begin{itemize}
\item FirstItem  \texttt{A command}\\


\item Something Big: what it does: \\
- \textit{Something}, what it does.\\
- \textit{Other}, what it does.

\end{itemize}

\section*{A section}

\subsubsection*{A subsection}
Something $"\texttt{some formatted code}:\textbf{code}"$\\

NOTE Something: $command$ (to write a method name for example) or use it for field name like $player\textbf{ID}$. 

\end{document}


    
    
